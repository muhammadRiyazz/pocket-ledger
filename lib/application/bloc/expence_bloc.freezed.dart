// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'expence_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ExpenceEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchlist,
    required TResult Function(ExpModel expdata, BuildContext contx) addExp,
    required TResult Function(ExpModel expdata, dynamic key, BuildContext contx)
        editExp,
    required TResult Function(dynamic key, BuildContext contx) deleteExp,
    required TResult Function(String date) listsort,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchlist,
    TResult? Function(ExpModel expdata, BuildContext contx)? addExp,
    TResult? Function(ExpModel expdata, dynamic key, BuildContext contx)?
        editExp,
    TResult? Function(dynamic key, BuildContext contx)? deleteExp,
    TResult? Function(String date)? listsort,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchlist,
    TResult Function(ExpModel expdata, BuildContext contx)? addExp,
    TResult Function(ExpModel expdata, dynamic key, BuildContext contx)?
        editExp,
    TResult Function(dynamic key, BuildContext contx)? deleteExp,
    TResult Function(String date)? listsort,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Fetchlist value) fetchlist,
    required TResult Function(AddExp value) addExp,
    required TResult Function(EditExp value) editExp,
    required TResult Function(DeleteExp value) deleteExp,
    required TResult Function(Listsort value) listsort,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Fetchlist value)? fetchlist,
    TResult? Function(AddExp value)? addExp,
    TResult? Function(EditExp value)? editExp,
    TResult? Function(DeleteExp value)? deleteExp,
    TResult? Function(Listsort value)? listsort,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Fetchlist value)? fetchlist,
    TResult Function(AddExp value)? addExp,
    TResult Function(EditExp value)? editExp,
    TResult Function(DeleteExp value)? deleteExp,
    TResult Function(Listsort value)? listsort,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExpenceEventCopyWith<$Res> {
  factory $ExpenceEventCopyWith(
          ExpenceEvent value, $Res Function(ExpenceEvent) then) =
      _$ExpenceEventCopyWithImpl<$Res, ExpenceEvent>;
}

/// @nodoc
class _$ExpenceEventCopyWithImpl<$Res, $Val extends ExpenceEvent>
    implements $ExpenceEventCopyWith<$Res> {
  _$ExpenceEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FetchlistImplCopyWith<$Res> {
  factory _$$FetchlistImplCopyWith(
          _$FetchlistImpl value, $Res Function(_$FetchlistImpl) then) =
      __$$FetchlistImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FetchlistImplCopyWithImpl<$Res>
    extends _$ExpenceEventCopyWithImpl<$Res, _$FetchlistImpl>
    implements _$$FetchlistImplCopyWith<$Res> {
  __$$FetchlistImplCopyWithImpl(
      _$FetchlistImpl _value, $Res Function(_$FetchlistImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FetchlistImpl implements Fetchlist {
  const _$FetchlistImpl();

  @override
  String toString() {
    return 'ExpenceEvent.fetchlist()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FetchlistImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchlist,
    required TResult Function(ExpModel expdata, BuildContext contx) addExp,
    required TResult Function(ExpModel expdata, dynamic key, BuildContext contx)
        editExp,
    required TResult Function(dynamic key, BuildContext contx) deleteExp,
    required TResult Function(String date) listsort,
  }) {
    return fetchlist();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchlist,
    TResult? Function(ExpModel expdata, BuildContext contx)? addExp,
    TResult? Function(ExpModel expdata, dynamic key, BuildContext contx)?
        editExp,
    TResult? Function(dynamic key, BuildContext contx)? deleteExp,
    TResult? Function(String date)? listsort,
  }) {
    return fetchlist?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchlist,
    TResult Function(ExpModel expdata, BuildContext contx)? addExp,
    TResult Function(ExpModel expdata, dynamic key, BuildContext contx)?
        editExp,
    TResult Function(dynamic key, BuildContext contx)? deleteExp,
    TResult Function(String date)? listsort,
    required TResult orElse(),
  }) {
    if (fetchlist != null) {
      return fetchlist();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Fetchlist value) fetchlist,
    required TResult Function(AddExp value) addExp,
    required TResult Function(EditExp value) editExp,
    required TResult Function(DeleteExp value) deleteExp,
    required TResult Function(Listsort value) listsort,
  }) {
    return fetchlist(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Fetchlist value)? fetchlist,
    TResult? Function(AddExp value)? addExp,
    TResult? Function(EditExp value)? editExp,
    TResult? Function(DeleteExp value)? deleteExp,
    TResult? Function(Listsort value)? listsort,
  }) {
    return fetchlist?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Fetchlist value)? fetchlist,
    TResult Function(AddExp value)? addExp,
    TResult Function(EditExp value)? editExp,
    TResult Function(DeleteExp value)? deleteExp,
    TResult Function(Listsort value)? listsort,
    required TResult orElse(),
  }) {
    if (fetchlist != null) {
      return fetchlist(this);
    }
    return orElse();
  }
}

abstract class Fetchlist implements ExpenceEvent {
  const factory Fetchlist() = _$FetchlistImpl;
}

/// @nodoc
abstract class _$$AddExpImplCopyWith<$Res> {
  factory _$$AddExpImplCopyWith(
          _$AddExpImpl value, $Res Function(_$AddExpImpl) then) =
      __$$AddExpImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ExpModel expdata, BuildContext contx});
}

/// @nodoc
class __$$AddExpImplCopyWithImpl<$Res>
    extends _$ExpenceEventCopyWithImpl<$Res, _$AddExpImpl>
    implements _$$AddExpImplCopyWith<$Res> {
  __$$AddExpImplCopyWithImpl(
      _$AddExpImpl _value, $Res Function(_$AddExpImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expdata = null,
    Object? contx = null,
  }) {
    return _then(_$AddExpImpl(
      expdata: null == expdata
          ? _value.expdata
          : expdata // ignore: cast_nullable_to_non_nullable
              as ExpModel,
      contx: null == contx
          ? _value.contx
          : contx // ignore: cast_nullable_to_non_nullable
              as BuildContext,
    ));
  }
}

/// @nodoc

class _$AddExpImpl implements AddExp {
  const _$AddExpImpl({required this.expdata, required this.contx});

  @override
  final ExpModel expdata;
  @override
  final BuildContext contx;

  @override
  String toString() {
    return 'ExpenceEvent.addExp(expdata: $expdata, contx: $contx)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddExpImpl &&
            (identical(other.expdata, expdata) || other.expdata == expdata) &&
            (identical(other.contx, contx) || other.contx == contx));
  }

  @override
  int get hashCode => Object.hash(runtimeType, expdata, contx);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddExpImplCopyWith<_$AddExpImpl> get copyWith =>
      __$$AddExpImplCopyWithImpl<_$AddExpImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchlist,
    required TResult Function(ExpModel expdata, BuildContext contx) addExp,
    required TResult Function(ExpModel expdata, dynamic key, BuildContext contx)
        editExp,
    required TResult Function(dynamic key, BuildContext contx) deleteExp,
    required TResult Function(String date) listsort,
  }) {
    return addExp(expdata, contx);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchlist,
    TResult? Function(ExpModel expdata, BuildContext contx)? addExp,
    TResult? Function(ExpModel expdata, dynamic key, BuildContext contx)?
        editExp,
    TResult? Function(dynamic key, BuildContext contx)? deleteExp,
    TResult? Function(String date)? listsort,
  }) {
    return addExp?.call(expdata, contx);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchlist,
    TResult Function(ExpModel expdata, BuildContext contx)? addExp,
    TResult Function(ExpModel expdata, dynamic key, BuildContext contx)?
        editExp,
    TResult Function(dynamic key, BuildContext contx)? deleteExp,
    TResult Function(String date)? listsort,
    required TResult orElse(),
  }) {
    if (addExp != null) {
      return addExp(expdata, contx);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Fetchlist value) fetchlist,
    required TResult Function(AddExp value) addExp,
    required TResult Function(EditExp value) editExp,
    required TResult Function(DeleteExp value) deleteExp,
    required TResult Function(Listsort value) listsort,
  }) {
    return addExp(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Fetchlist value)? fetchlist,
    TResult? Function(AddExp value)? addExp,
    TResult? Function(EditExp value)? editExp,
    TResult? Function(DeleteExp value)? deleteExp,
    TResult? Function(Listsort value)? listsort,
  }) {
    return addExp?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Fetchlist value)? fetchlist,
    TResult Function(AddExp value)? addExp,
    TResult Function(EditExp value)? editExp,
    TResult Function(DeleteExp value)? deleteExp,
    TResult Function(Listsort value)? listsort,
    required TResult orElse(),
  }) {
    if (addExp != null) {
      return addExp(this);
    }
    return orElse();
  }
}

abstract class AddExp implements ExpenceEvent {
  const factory AddExp(
      {required final ExpModel expdata,
      required final BuildContext contx}) = _$AddExpImpl;

  ExpModel get expdata;
  BuildContext get contx;
  @JsonKey(ignore: true)
  _$$AddExpImplCopyWith<_$AddExpImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EditExpImplCopyWith<$Res> {
  factory _$$EditExpImplCopyWith(
          _$EditExpImpl value, $Res Function(_$EditExpImpl) then) =
      __$$EditExpImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ExpModel expdata, dynamic key, BuildContext contx});
}

/// @nodoc
class __$$EditExpImplCopyWithImpl<$Res>
    extends _$ExpenceEventCopyWithImpl<$Res, _$EditExpImpl>
    implements _$$EditExpImplCopyWith<$Res> {
  __$$EditExpImplCopyWithImpl(
      _$EditExpImpl _value, $Res Function(_$EditExpImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expdata = null,
    Object? key = freezed,
    Object? contx = null,
  }) {
    return _then(_$EditExpImpl(
      expdata: null == expdata
          ? _value.expdata
          : expdata // ignore: cast_nullable_to_non_nullable
              as ExpModel,
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as dynamic,
      contx: null == contx
          ? _value.contx
          : contx // ignore: cast_nullable_to_non_nullable
              as BuildContext,
    ));
  }
}

/// @nodoc

class _$EditExpImpl implements EditExp {
  const _$EditExpImpl(
      {required this.expdata, required this.key, required this.contx});

  @override
  final ExpModel expdata;
  @override
  final dynamic key;
  @override
  final BuildContext contx;

  @override
  String toString() {
    return 'ExpenceEvent.editExp(expdata: $expdata, key: $key, contx: $contx)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EditExpImpl &&
            (identical(other.expdata, expdata) || other.expdata == expdata) &&
            const DeepCollectionEquality().equals(other.key, key) &&
            (identical(other.contx, contx) || other.contx == contx));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, expdata, const DeepCollectionEquality().hash(key), contx);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EditExpImplCopyWith<_$EditExpImpl> get copyWith =>
      __$$EditExpImplCopyWithImpl<_$EditExpImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchlist,
    required TResult Function(ExpModel expdata, BuildContext contx) addExp,
    required TResult Function(ExpModel expdata, dynamic key, BuildContext contx)
        editExp,
    required TResult Function(dynamic key, BuildContext contx) deleteExp,
    required TResult Function(String date) listsort,
  }) {
    return editExp(expdata, key, contx);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchlist,
    TResult? Function(ExpModel expdata, BuildContext contx)? addExp,
    TResult? Function(ExpModel expdata, dynamic key, BuildContext contx)?
        editExp,
    TResult? Function(dynamic key, BuildContext contx)? deleteExp,
    TResult? Function(String date)? listsort,
  }) {
    return editExp?.call(expdata, key, contx);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchlist,
    TResult Function(ExpModel expdata, BuildContext contx)? addExp,
    TResult Function(ExpModel expdata, dynamic key, BuildContext contx)?
        editExp,
    TResult Function(dynamic key, BuildContext contx)? deleteExp,
    TResult Function(String date)? listsort,
    required TResult orElse(),
  }) {
    if (editExp != null) {
      return editExp(expdata, key, contx);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Fetchlist value) fetchlist,
    required TResult Function(AddExp value) addExp,
    required TResult Function(EditExp value) editExp,
    required TResult Function(DeleteExp value) deleteExp,
    required TResult Function(Listsort value) listsort,
  }) {
    return editExp(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Fetchlist value)? fetchlist,
    TResult? Function(AddExp value)? addExp,
    TResult? Function(EditExp value)? editExp,
    TResult? Function(DeleteExp value)? deleteExp,
    TResult? Function(Listsort value)? listsort,
  }) {
    return editExp?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Fetchlist value)? fetchlist,
    TResult Function(AddExp value)? addExp,
    TResult Function(EditExp value)? editExp,
    TResult Function(DeleteExp value)? deleteExp,
    TResult Function(Listsort value)? listsort,
    required TResult orElse(),
  }) {
    if (editExp != null) {
      return editExp(this);
    }
    return orElse();
  }
}

abstract class EditExp implements ExpenceEvent {
  const factory EditExp(
      {required final ExpModel expdata,
      required final dynamic key,
      required final BuildContext contx}) = _$EditExpImpl;

  ExpModel get expdata;
  dynamic get key;
  BuildContext get contx;
  @JsonKey(ignore: true)
  _$$EditExpImplCopyWith<_$EditExpImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DeleteExpImplCopyWith<$Res> {
  factory _$$DeleteExpImplCopyWith(
          _$DeleteExpImpl value, $Res Function(_$DeleteExpImpl) then) =
      __$$DeleteExpImplCopyWithImpl<$Res>;
  @useResult
  $Res call({dynamic key, BuildContext contx});
}

/// @nodoc
class __$$DeleteExpImplCopyWithImpl<$Res>
    extends _$ExpenceEventCopyWithImpl<$Res, _$DeleteExpImpl>
    implements _$$DeleteExpImplCopyWith<$Res> {
  __$$DeleteExpImplCopyWithImpl(
      _$DeleteExpImpl _value, $Res Function(_$DeleteExpImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? contx = null,
  }) {
    return _then(_$DeleteExpImpl(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as dynamic,
      contx: null == contx
          ? _value.contx
          : contx // ignore: cast_nullable_to_non_nullable
              as BuildContext,
    ));
  }
}

/// @nodoc

class _$DeleteExpImpl implements DeleteExp {
  const _$DeleteExpImpl({required this.key, required this.contx});

  @override
  final dynamic key;
  @override
  final BuildContext contx;

  @override
  String toString() {
    return 'ExpenceEvent.deleteExp(key: $key, contx: $contx)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteExpImpl &&
            const DeepCollectionEquality().equals(other.key, key) &&
            (identical(other.contx, contx) || other.contx == contx));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(key), contx);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteExpImplCopyWith<_$DeleteExpImpl> get copyWith =>
      __$$DeleteExpImplCopyWithImpl<_$DeleteExpImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchlist,
    required TResult Function(ExpModel expdata, BuildContext contx) addExp,
    required TResult Function(ExpModel expdata, dynamic key, BuildContext contx)
        editExp,
    required TResult Function(dynamic key, BuildContext contx) deleteExp,
    required TResult Function(String date) listsort,
  }) {
    return deleteExp(key, contx);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchlist,
    TResult? Function(ExpModel expdata, BuildContext contx)? addExp,
    TResult? Function(ExpModel expdata, dynamic key, BuildContext contx)?
        editExp,
    TResult? Function(dynamic key, BuildContext contx)? deleteExp,
    TResult? Function(String date)? listsort,
  }) {
    return deleteExp?.call(key, contx);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchlist,
    TResult Function(ExpModel expdata, BuildContext contx)? addExp,
    TResult Function(ExpModel expdata, dynamic key, BuildContext contx)?
        editExp,
    TResult Function(dynamic key, BuildContext contx)? deleteExp,
    TResult Function(String date)? listsort,
    required TResult orElse(),
  }) {
    if (deleteExp != null) {
      return deleteExp(key, contx);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Fetchlist value) fetchlist,
    required TResult Function(AddExp value) addExp,
    required TResult Function(EditExp value) editExp,
    required TResult Function(DeleteExp value) deleteExp,
    required TResult Function(Listsort value) listsort,
  }) {
    return deleteExp(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Fetchlist value)? fetchlist,
    TResult? Function(AddExp value)? addExp,
    TResult? Function(EditExp value)? editExp,
    TResult? Function(DeleteExp value)? deleteExp,
    TResult? Function(Listsort value)? listsort,
  }) {
    return deleteExp?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Fetchlist value)? fetchlist,
    TResult Function(AddExp value)? addExp,
    TResult Function(EditExp value)? editExp,
    TResult Function(DeleteExp value)? deleteExp,
    TResult Function(Listsort value)? listsort,
    required TResult orElse(),
  }) {
    if (deleteExp != null) {
      return deleteExp(this);
    }
    return orElse();
  }
}

abstract class DeleteExp implements ExpenceEvent {
  const factory DeleteExp(
      {required final dynamic key,
      required final BuildContext contx}) = _$DeleteExpImpl;

  dynamic get key;
  BuildContext get contx;
  @JsonKey(ignore: true)
  _$$DeleteExpImplCopyWith<_$DeleteExpImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ListsortImplCopyWith<$Res> {
  factory _$$ListsortImplCopyWith(
          _$ListsortImpl value, $Res Function(_$ListsortImpl) then) =
      __$$ListsortImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String date});
}

/// @nodoc
class __$$ListsortImplCopyWithImpl<$Res>
    extends _$ExpenceEventCopyWithImpl<$Res, _$ListsortImpl>
    implements _$$ListsortImplCopyWith<$Res> {
  __$$ListsortImplCopyWithImpl(
      _$ListsortImpl _value, $Res Function(_$ListsortImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? date = null,
  }) {
    return _then(_$ListsortImpl(
      date: null == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ListsortImpl implements Listsort {
  const _$ListsortImpl({required this.date});

  @override
  final String date;

  @override
  String toString() {
    return 'ExpenceEvent.listsort(date: $date)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListsortImpl &&
            (identical(other.date, date) || other.date == date));
  }

  @override
  int get hashCode => Object.hash(runtimeType, date);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListsortImplCopyWith<_$ListsortImpl> get copyWith =>
      __$$ListsortImplCopyWithImpl<_$ListsortImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchlist,
    required TResult Function(ExpModel expdata, BuildContext contx) addExp,
    required TResult Function(ExpModel expdata, dynamic key, BuildContext contx)
        editExp,
    required TResult Function(dynamic key, BuildContext contx) deleteExp,
    required TResult Function(String date) listsort,
  }) {
    return listsort(date);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchlist,
    TResult? Function(ExpModel expdata, BuildContext contx)? addExp,
    TResult? Function(ExpModel expdata, dynamic key, BuildContext contx)?
        editExp,
    TResult? Function(dynamic key, BuildContext contx)? deleteExp,
    TResult? Function(String date)? listsort,
  }) {
    return listsort?.call(date);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchlist,
    TResult Function(ExpModel expdata, BuildContext contx)? addExp,
    TResult Function(ExpModel expdata, dynamic key, BuildContext contx)?
        editExp,
    TResult Function(dynamic key, BuildContext contx)? deleteExp,
    TResult Function(String date)? listsort,
    required TResult orElse(),
  }) {
    if (listsort != null) {
      return listsort(date);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Fetchlist value) fetchlist,
    required TResult Function(AddExp value) addExp,
    required TResult Function(EditExp value) editExp,
    required TResult Function(DeleteExp value) deleteExp,
    required TResult Function(Listsort value) listsort,
  }) {
    return listsort(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Fetchlist value)? fetchlist,
    TResult? Function(AddExp value)? addExp,
    TResult? Function(EditExp value)? editExp,
    TResult? Function(DeleteExp value)? deleteExp,
    TResult? Function(Listsort value)? listsort,
  }) {
    return listsort?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Fetchlist value)? fetchlist,
    TResult Function(AddExp value)? addExp,
    TResult Function(EditExp value)? editExp,
    TResult Function(DeleteExp value)? deleteExp,
    TResult Function(Listsort value)? listsort,
    required TResult orElse(),
  }) {
    if (listsort != null) {
      return listsort(this);
    }
    return orElse();
  }
}

abstract class Listsort implements ExpenceEvent {
  const factory Listsort({required final String date}) = _$ListsortImpl;

  String get date;
  @JsonKey(ignore: true)
  _$$ListsortImplCopyWith<_$ListsortImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ExpenceState {
  bool get isLoading => throw _privateConstructorUsedError;
  bool get isError => throw _privateConstructorUsedError;
  String get lastweekexp => throw _privateConstructorUsedError;
  List<ExpModel> get explist => throw _privateConstructorUsedError;
  List<ExpModel> get filterlist => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ExpenceStateCopyWith<ExpenceState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExpenceStateCopyWith<$Res> {
  factory $ExpenceStateCopyWith(
          ExpenceState value, $Res Function(ExpenceState) then) =
      _$ExpenceStateCopyWithImpl<$Res, ExpenceState>;
  @useResult
  $Res call(
      {bool isLoading,
      bool isError,
      String lastweekexp,
      List<ExpModel> explist,
      List<ExpModel> filterlist});
}

/// @nodoc
class _$ExpenceStateCopyWithImpl<$Res, $Val extends ExpenceState>
    implements $ExpenceStateCopyWith<$Res> {
  _$ExpenceStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoading = null,
    Object? isError = null,
    Object? lastweekexp = null,
    Object? explist = null,
    Object? filterlist = null,
  }) {
    return _then(_value.copyWith(
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      isError: null == isError
          ? _value.isError
          : isError // ignore: cast_nullable_to_non_nullable
              as bool,
      lastweekexp: null == lastweekexp
          ? _value.lastweekexp
          : lastweekexp // ignore: cast_nullable_to_non_nullable
              as String,
      explist: null == explist
          ? _value.explist
          : explist // ignore: cast_nullable_to_non_nullable
              as List<ExpModel>,
      filterlist: null == filterlist
          ? _value.filterlist
          : filterlist // ignore: cast_nullable_to_non_nullable
              as List<ExpModel>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ExpenceStateImplCopyWith<$Res>
    implements $ExpenceStateCopyWith<$Res> {
  factory _$$ExpenceStateImplCopyWith(
          _$ExpenceStateImpl value, $Res Function(_$ExpenceStateImpl) then) =
      __$$ExpenceStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool isLoading,
      bool isError,
      String lastweekexp,
      List<ExpModel> explist,
      List<ExpModel> filterlist});
}

/// @nodoc
class __$$ExpenceStateImplCopyWithImpl<$Res>
    extends _$ExpenceStateCopyWithImpl<$Res, _$ExpenceStateImpl>
    implements _$$ExpenceStateImplCopyWith<$Res> {
  __$$ExpenceStateImplCopyWithImpl(
      _$ExpenceStateImpl _value, $Res Function(_$ExpenceStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoading = null,
    Object? isError = null,
    Object? lastweekexp = null,
    Object? explist = null,
    Object? filterlist = null,
  }) {
    return _then(_$ExpenceStateImpl(
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      isError: null == isError
          ? _value.isError
          : isError // ignore: cast_nullable_to_non_nullable
              as bool,
      lastweekexp: null == lastweekexp
          ? _value.lastweekexp
          : lastweekexp // ignore: cast_nullable_to_non_nullable
              as String,
      explist: null == explist
          ? _value._explist
          : explist // ignore: cast_nullable_to_non_nullable
              as List<ExpModel>,
      filterlist: null == filterlist
          ? _value._filterlist
          : filterlist // ignore: cast_nullable_to_non_nullable
              as List<ExpModel>,
    ));
  }
}

/// @nodoc

class _$ExpenceStateImpl implements _ExpenceState {
  _$ExpenceStateImpl(
      {required this.isLoading,
      required this.isError,
      required this.lastweekexp,
      required final List<ExpModel> explist,
      required final List<ExpModel> filterlist})
      : _explist = explist,
        _filterlist = filterlist;

  @override
  final bool isLoading;
  @override
  final bool isError;
  @override
  final String lastweekexp;
  final List<ExpModel> _explist;
  @override
  List<ExpModel> get explist {
    if (_explist is EqualUnmodifiableListView) return _explist;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_explist);
  }

  final List<ExpModel> _filterlist;
  @override
  List<ExpModel> get filterlist {
    if (_filterlist is EqualUnmodifiableListView) return _filterlist;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filterlist);
  }

  @override
  String toString() {
    return 'ExpenceState(isLoading: $isLoading, isError: $isError, lastweekexp: $lastweekexp, explist: $explist, filterlist: $filterlist)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExpenceStateImpl &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.isError, isError) || other.isError == isError) &&
            (identical(other.lastweekexp, lastweekexp) ||
                other.lastweekexp == lastweekexp) &&
            const DeepCollectionEquality().equals(other._explist, _explist) &&
            const DeepCollectionEquality()
                .equals(other._filterlist, _filterlist));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      isLoading,
      isError,
      lastweekexp,
      const DeepCollectionEquality().hash(_explist),
      const DeepCollectionEquality().hash(_filterlist));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExpenceStateImplCopyWith<_$ExpenceStateImpl> get copyWith =>
      __$$ExpenceStateImplCopyWithImpl<_$ExpenceStateImpl>(this, _$identity);
}

abstract class _ExpenceState implements ExpenceState {
  factory _ExpenceState(
      {required final bool isLoading,
      required final bool isError,
      required final String lastweekexp,
      required final List<ExpModel> explist,
      required final List<ExpModel> filterlist}) = _$ExpenceStateImpl;

  @override
  bool get isLoading;
  @override
  bool get isError;
  @override
  String get lastweekexp;
  @override
  List<ExpModel> get explist;
  @override
  List<ExpModel> get filterlist;
  @override
  @JsonKey(ignore: true)
  _$$ExpenceStateImplCopyWith<_$ExpenceStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
